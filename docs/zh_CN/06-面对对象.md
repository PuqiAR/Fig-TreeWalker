# 面对对象

> Fig中只有结构体(`struct`) 遵循go圣经 组合由于继承 (struct组合尚未推出)

## 结构体定义
完整语法：
```cpp
struct Point
{
    public x: Int; // 公开字段
    public y: Int; // 公开字段
}

struct Person
{
    name: String; // 私有字段，无法被外部访问
    age: Int; // 私有字段，无法被外部访问
    sex: String = "Airplane"; // 私有字段，无法被外部访问

    public func getName() -> String // 公开类函数
    {
        return name;
    }
}
```

## 结构体初始化
语法：
```go

// 位置参数构造
var person := new Person{
    "Fig", // name
    1,     // age
    "Language" // sex
};
```

```go
// 命名参数构造模式，可以无序
var person := new Person{
    name: "Fig",
    age: 1,
    sex: "Language"
};
```

```go
// 语法糖：同名变量构造
const name := "Fig";
const age := 1;
const sex := "Language";

var person := new Person{sex, name, age}; // 可以无序，自动匹配
```

请注意，同名变量构造(shorthand)模式请规范使用：
&nbsp;
示例：定义
```cpp
struct Point
{
    public x;
    public y;
}
```
使用：
```go
var a := Point{1,2};
io.println(a.x, a.y); // 1 2

var x := 7;
var y := 6;
var b := Point{y, x};
io.println(b.x, b.y); // 7 6
// ??
```

使用该模式最好有序构造，如果你清楚你在做什么，完全可以利用它

## 结构体运算符重载

**目前不支持**

## 接口与实现
`interface` 与 `implement`

### 定义接口
```go
interface Printable
{
    toString() -> String;
    getName() -> String
    {
        return "Printable";
    }
}
```

使用 `interface` + 名字 {内容}定义结构体
方法签名为 `method() -> type`，其中必须提供返回类型，这是约定。
提供默认方法将在子类实现为实现情况下自动替补

### 实现
```rust
struct Person
{
    name: String;
    age: Int;
}

impl Printable for Person
{
    toString()
    {
        return name + ":" + age;
    }
    getName()
    {
        return "Person";
    }
}
```

实现时不需要也不允许提供返回类型，必须与`interface`约定一致
内部通过动态派发 vtable实现